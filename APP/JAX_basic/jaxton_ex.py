# -*- coding: utf-8 -*-
"""jaxton_ex.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1u5_WN39xv0bFjM9TPvp7AQzV7mzduX-M

<center>
    <h1>JaxTon</h1>
    <i>ðŸ’¯ JAX exercises</i>
    <br>
    <br>
    <a href='https://github.com/vopani/jaxton/blob/master/LICENSE'>
        <img src='https://img.shields.io/badge/license-Apache%202.0-blue.svg?logo=apache'>
    </a>
    <a href='https://github.com/vopani/jaxton'>
        <img src='https://img.shields.io/github/stars/vopani/jaxton?color=yellowgreen&logo=github'>
    </a>
    <a href='https://twitter.com/vopani'>
        <img src='https://img.shields.io/twitter/follow/vopani'>
    </a>
</center>

<center>
    All exercises of <b>JaxTon</b>: <i>ðŸ’¯ JAX exercises</i>
    <br>
    You can find individual sets of the exercises and solutions on <a href="https://github.com/vopani/jaxton#exercises-">GitHub</a>
</center>

**Prerequisites**

* The configuration of jax should be updated as shown in the code snippet below in order to use TPUs.
* A sample array `sample_data` will be used for some of the exercises.
* Sample functions `square`, `cube` and `areas` will be used for some of the exercises.
"""

## install jax
!python3 -m pip install jax

## import packages
import jax
import jax.numpy as jnp
import math
import os
import requests

## setup JAX to use TPUs if available
try:
    url = 'http:' + os.environ['TPU_NAME'].split(':')[1] + ':8475/requestversion/tpu_driver_nightly'
    resp = requests.post(url)
    jax.config.FLAGS.jax_xla_backend = 'tpu_driver'
    jax.config.FLAGS.jax_backend_target = os.environ['TPU_NAME']
except:
    pass

jax.devices()

## sample data
sample_data = jnp.array([10, 1, 24, 20, 15, 14])
sample_data

## sample square function
def square(x):
    return x**2

square(2)

## sample cube function
def cube(x):
    return x**3

cube(2)

## sample areas function
def areas(x):
    return [math.sqrt(3)*x**2/4, x**2, math.pi*x**2]

areas(2)

"""**Exercise 1: Install the `jax` package**"""

pip install jax

"""**Exercise 2: Import the `jax` package**"""

import jax

"""**Exercise 3: Display the version of `jax`**"""

jax.__version__

"""**Exercise 4: Display the default backend of `jax`**"""

jax.default_backend()

"""**Exercise 5: Display the devices of the backend**"""

jax.devices()

"""**Exercise 6: Create a JAX DeviceArray with values [10, 1, 24] and assign it to `data`**"""

data = jnp.array([10,1,24])

"""**Exercise 7: Display the type of `data`**"""

type(data)

"""**Exercise 8: Display the shape of `data`**"""

data.shape

"""**Exercise 9: Transfer `data` to host and assign it to `data_host`**"""

data_host = jax.device_get(data)
type(data_host)

"""**Exercise 10: Transfer `data_host` to device and assign it to `data_device`**"""

data_device = jax.device_put(data_host)
type(data_device)

"""**Exercise 11: Create a matrix with values [[10, 1, 24], [20, 15, 14]] and assign it to `data`**"""

data = jnp.array([[10,1,24],[20,15,14]])

"""**Exercise 12: Assign the transpose of `data` to `dataT`**"""

dataT = data.T

"""**Exercise 13: Assign the element of `data` at index [0, 2] to `value`**"""

value = data[0,2]
value

"""**Exercise 14: Update the value of `data` at index [1, 1] to `100`**"""

data = data.at[1,1].set(100)
data

"""**Exercise 15: Add `41` to the value of `data` at index [0, 0]**"""

data = data.at[0,0].add(41)
data

"""**Exercise 16: Calculate the minimum values over axis=1 and assign it to `mins`**"""

mins = jnp.min(data, axis =1)

"""**Exercise 17: Select the first row of values of `data` and assign it to `data_select`**"""

data_select = data[0,:]
data_select

"""**Exercise 18: Append the row `data_select` to `data`**"""

#data = jnp.vstack([data,data_select])
data

"""**Exercise 19: Multiply the matrices `data` and `dataT` and assign it to `data_prod`**"""

data_prod = jnp.dot(data,dataT)
data_prod

"""**Exercise 20: Convert the dtype of `data_prod` to `float32`**"""

data_prod = jnp.array(data_prod, dtype=jnp.float32)
data_prod

"""**Exercise 21: Create a pseudorandom number generator key with seed=100 and assign it to `key`**"""

seed =100
key = jax.random.PRNGKey(seed)
key

"""**Exercise 22: Create a subkey from `key` and assign it to `subkey`**"""

key, subkey = jax.random.split(key)
key, subkey

"""**Exercise 23: Split `key` into seven subkeys `key_1`, `key_2`, `key_3`, `key_4`, `key_5`, `key_6` and `key_7`**"""

key_1, key_2, key_3, key_4, key_5, key_6, key_7 = jax.random.split(key, num=7)
key_1

"""**Exercise 24: Create a random permutation of `sample_data` using `key_1` and assign it to `data_permutation`**"""

data_permutation = jax.random.permutation(key_1,sample_data)
data_permutation

"""**Exercise 25: Choose a random element from `sample_data` using `key_2` and assign it to `random_selection`**"""

random_selection = jax.random.choice(key_2,sample_data)
random_selection

"""**Exercise 26: Sample an integer between 10 and 24 using `key_3` and assign it to `sample_int`**"""

sample_int = jax.random.randint(key_3, shape=(1,), minval=10, maxval=24)
sample_int

"""

```
# This is formatted as code
```

**Exercise 27: Sample two values from uniform distribution between 1 and 2 using `key_4` and assign it to `sample_uniform`**"""

sample_uniform = jax.random.uniform(key=key_4, shape=(2,),minval=1, maxval=2)
sample_uniform

"""**Exercise 28: Sample three values from bernoulli distribution using `key_5` and assign it to `sample_bernoulli`**"""

sample_bernoulli = jax.random.bernoulli(key_5,shape=(3,) )
sample_bernoulli

"""**Exercise 29: Sample a 2x3 matrix from poisson distribution with Î»=100 using `key_6` and assign it to `sample_poisson`**"""

sample_poisson = jax.random.poisson(key_6, shape=(2,3), lam=100 )
sample_poisson

"""**Exercise 30: Sample a 2x3x4 array from normal distribution using `key_7` and assign it to `sample_normal`**"""

sample_normal = jax.random.normal(key_7, shape=(2,3,4))
sample_normal



"""**Exercise 31: JIT-compile the `cube` function and assign it to `cube_jit`**"""

cube_jit = jax.jit(cube)

"""**Exercise 32: Display the execution time of `cube_jit` for first run (with overhead) with input=10.24**"""

# Commented out IPython magic to ensure Python compatibility.
# %%time
# cube_jit(10.24)

"""**Exercise 33: Display execution time of `cube_jit` for second run (without overhead) with input=10.24**"""

# Commented out IPython magic to ensure Python compatibility.
# %%time 
# cube_jit(10.24)

"""**Exercise 34: Run `cube_jit` with input=10.24 and assign it to `cube_value`**"""

cube_value = cube_jit(10.24)
cube_value

"""**Exercise 35: Run `cube_jit` with jit disabled and input=10.24 and assign it to `cube_value_nojit`**"""

with jax.disable_jit():
  cube_value_nojit = cube_jit(10.24)
cube_value_nojit

"""**Exercise 36: Evaluate the shape of `cube_jit` with input=10.24 and assign it to `cube_shape`**"""

cube_shape = jax.eval_shape(cube_jit, 10.24)
cube_shape,cube_jit

"""**Exercise 37: Create the jaxpr of `cube_jit` with input=10.24 and 

---

assign it to `cube_jaxpr`**
"""

cube_jaxpr = jax.make_jaxpr(cube_jit)(10.24)
print(cube_jaxpr)

"""**Exercise 38: Assign the XLA computation of `cube_jit` with input=10.24 to `cube_xla` and print it's XLA HLO text**"""

cube_xla = jax.xla_computation(cube_jit)(10.24)
print(cube_xla.as_hlo_text())

"""**Exercise 39: Use the name `jaxton_cube_fn` internally for the `cube_jit` function and assign the named function to `cube_named_jit`**"""

cube_named_jit = jax.named_call(cube_jit, name='jaxton_cube_fn')
cube_named_jit

"""**Exercise 40: Assign the XLA computation of `cube_named_jit` with input=10.24 to `cube_named_xla` and print it's XLA HLO text**"""

cube_named_xla = jax.xla_computation(cube_named_jit)(10.24)
print(cube_named_xla.as_hlo_text(),cube_named_xla)

"""**Exercise 41: Calculate the cumulative sum of `sample_data` using the associative scan operator and assign it to `data_cumsum`**"""

data_cumsum = jnp.cumsum(sample_data)
sample_data,data_cumsum

"""**Exercise 42: Calculate the cumulative sum of `sample_data` in reverse order using the associative scan operator and assign it to `data_cumsum_reverse`**"""

data_cumsum_reverse = jax.lax.associative_scan(jnp.add, sample_data, reverse=True)
data_cumsum_reverse

"""**Exercise 43: Create a JIT-compiled lambda function that outputs `square` of input if it is even and `cube` of input if it is odd using the cond operator and assign it to `parity_ifelse`**"""

parity_iflese = jax.jit(lambda x: jax.lax.cond( jnp.remainder(x, 2) ==0 ,square,cube,x))
parity_iflese

"""**Exercise 44: Run `parity_ifelse` with the first element of `data_cumsum` and assign it to `parity_1`**"""

parity_1 = parity_iflese(data_cumsum[0])
parity_1

"""**Exercise 45: Run `parity_ifelse` with the second element of `data_cumsum` and assign it to `parity_2`**"""

parity_2 = parity_iflese(data_cumsum[1])
parity_2

"""**Exercise 46: Create a JIT-compiled lambda function that outputs `square` of input if it is even and `cube` of input if it is odd using the switch operator and assign it to `parity_switch`**"""

parity_switch = jax.jit(lambda x: jax.lax.switch(jnp.remainder(x,2) ,[square,cube],x) )
parity_switch

"""**Exercise 47: Run `parity_switch` with the fourth element of `data_cumsum` and assign it to `parity_4`**"""

parity_4 = parity_switch(data_cumsum[3])
parity_4,data_cumsum[3]

"""**Exercise 48: Run `parity_switch` with the fifth element of `data_cumsum` and assign it to `parity_5`**"""

parity_5 = parity_switch(data_cumsum[4])
parity_5

"""**Exercise 49: Calculate the sum of the first four elements of `data_cumsum` using the for operator and assign it to `sum_four`**"""

sum_four = jax.lax.fori_loop(0,4, lambda i,x: x + data_cumsum[i], 0)
sum_four

"""**Exercise 50: Keep subtracting 25 from `sum_four` until the result is negative using the while operator and assign it to `subtract_until_negative`**"""

subtract_until_negative = jax.lax.while_loop(lambda x: x>0, lambda x: x -25 ,sum_four)
subtract_until_negative

"""**Exercise 51: JIT-compile the derivative of `cube` and assign it to `derivative_cube`**"""

derivative_cube = jax.jit(jax.grad(cube))

"""**Exercise 52: Run `derivative_cube` with value=7**"""

derivative_cube(7.0)

"""**Exercise 53: JIT-compile the value and derivative of `cube` together, assign it to `value_and_derivative_cube` and run it with value=7**"""

value_and_derivative_cube = jax.jit(jax.value_and_grad(cube))
value_and_derivative_cube(7.0)

"""**Exercise 54: JIT-compile the second order derivative of `cube`, assign it to `derivative_cube_2` and run it with value=7**"""

derivative_cube_2 = jax.jit(jax.grad(jax.grad(cube)))
derivative_cube_2(7.0)

"""**Exercise 55: JIT-compile the hessian of `cube`, assign it to `hessian_cube` and run it with value=7**"""

hessian_cube = jax.jit(jax.hessian(cube))
hessian_cube(7.0)

"""**Exercise 56: JIT-compile `areas`, assign it to `jit_areas` and run it with value=9**"""

jit_areas = jax.jit(areas)
jit_areas(9.0)

"""**Exercise 57: Compute the Jacobian of `areas` using forward-mode automatic differentiation, assign it to `jacfwd_areas` and run it with value=9**"""

jacfwd_areas = jax.jit(jax.jacobian(areas))
jacfwd_areas(9.0)

"""**Exercise 58: Compute the Jacobian of `areas` using reverse-mode automatic differentiation, assign it to `jacrev_areas` and run it with value=9**"""

jacrev_areas = jax.jacrev(areas)
jacrev_areas(9.0)

"""**Exercise 59: Compute the Jacobian-vector product of `cube` at value=7 with vector=9 and assign it to `jvp_cube`**"""

jvp_cube = jax.jvp(cube, (7.0,), (9.0,))
jvp_cube

"""**Exercise 60: Compute the linear approximation of `areas` with value=5, assign it to `areas_linear` and run it with value=9**"""

_, areas_linear = jax.linearize(areas, 5.0)
areas_linear(9.0)

"""<center>
    All exercises of <b>JaxTon</b>: <i>ðŸ’¯ JAX exercises</i>
    <br>
    You can find individual sets of the exercises and solutions on <a href="https://github.com/vopani/jaxton#exercises-">GitHub</a>
</center>
"""